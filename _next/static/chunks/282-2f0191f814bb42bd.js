(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[282],{8128:function(){},3773:function(e,n,t){"use strict";function i(e,n){for(let t of n)e[t]=e[t].bind(e)}t.d(n,{ak:function(){return i},w6:function(){return function e(n,t){return void 0===t?e(0,n):Array(t-n).fill(null).map((e,t)=>n+t)}}})},7526:function(e,n,t){"use strict";var i,r,o;function a(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];return e=>{for(let t of n)"function"==typeof t?t(e):null===t||"object"==typeof t&&t.hasOwnProperty("current")&&(t.current=e)}}function s(e,n,t){let i=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>{},t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:()=>{};return i=>{if(i instanceof MouseEvent){if(0!==i.button)return;let r=i.clientX,o=i.clientY,a=e=>{let n=e.clientX-r,i=e.clientY-o;return document.body.removeEventListener("mousemove",s),window.removeEventListener("mouseup",a),t(e,{x:e.clientX,y:e.clientY,dx:n,dy:i})},s=n=>{let t=n.clientX-r,i=n.clientY-o;return r=n.clientX,o=n.clientY,e(n,{x:n.clientX,y:n.clientY,dx:t,dy:i})};return document.body.addEventListener("mousemove",s,{passive:!1}),window.addEventListener("mouseup",a,{passive:!1}),n(i,{x:r,y:o},a,s)}{i.preventDefault();let r=i.changedTouches,o=r[0].identifier,a=r[0].clientX,s=r[0].clientY,l=e=>{for(let n of(e.preventDefault(),Array.from(e.changedTouches))){if(n.identifier!==o)continue;let i=n.clientX-a,r=n.clientY-s;return window.removeEventListener("touchend",l,{capture:!1,passive:!1}),window.removeEventListener("touchcancel",l,{capture:!1,passive:!1}),window.removeEventListener("touchmove",c,{capture:!1,passive:!1}),t(e,{x:n.clientX,y:n.clientY,dx:i,dy:r})}},c=n=>{for(let t of(n.preventDefault(),Array.from(n.changedTouches))){if(t.identifier!==o)continue;let i=t.clientX-a,r=t.clientY-s;return a=t.clientX,s=t.clientY,e(n,{x:t.clientX,y:t.clientY,dx:i,dy:r})}};return window.addEventListener("touchend",l,{capture:!1,passive:!1}),window.addEventListener("touchcancel",l,{capture:!1,passive:!1}),window.addEventListener("touchmove",c,{capture:!1,passive:!1}),n(i,{x:a,y:s},l,c)}}}(e,n,t);return{"data-affords":"click",onMouseDown:e=>i(e.nativeEvent),onTouchStart:e=>i(e.nativeEvent)}}t.d(n,{zb:function(){return a},dz:function(){return s}}),t(4090),null===(r=(o=window).matchMedia)||void 0===r||null===(i=r.call(o,"(any-hover: hover)"))||void 0===i||i.matches},7354:function(e,n,t){"use strict";function i(e,n,t){if(!n.has(e))throw TypeError("attempted to "+t+" private field on non-instance");return n.get(e)}t.d(n,{J:function(){return i}})},2731:function(e,n,t){"use strict";t.d(n,{_:function(){return r}});var i=t(7354);function r(e,n){var t=(0,i.J)(e,n,"get");return t.get?t.get.call(e):t.value}},9258:function(e,n,t){"use strict";function i(e,n,t){!function(e,n){if(n.has(e))throw TypeError("Cannot initialize the same private elements twice on an object")}(e,n),n.set(e,t)}t.d(n,{_:function(){return i}})},5577:function(e,n,t){"use strict";t.d(n,{_:function(){return r}});var i=t(7354);function r(e,n,t){var r=(0,i.J)(e,n,"set");return!function(e,n,t){if(n.set)n.set.call(e,t);else{if(!n.writable)throw TypeError("attempted to set read only private field");n.value=t}}(e,r,t),t}},6093:function(e,n,t){"use strict";function i(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}t.d(n,{_:function(){return i}})},6934:function(e,n,t){"use strict";t.d(n,{Y:function(){return r}});var i=t(6376);class r extends i.ShaderMaterial{constructor(e){super({type:"LineMaterial",uniforms:i.UniformsUtils.clone(i.UniformsUtils.merge([i.UniformsLib.common,i.UniformsLib.fog,{worldUnits:{value:1},linewidth:{value:1},resolution:{value:new i.Vector2(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}}])),vertexShader:"\n				#include <common>\n				#include <fog_pars_vertex>\n				#include <logdepthbuf_pars_vertex>\n				#include <clipping_planes_pars_vertex>\n\n				uniform float linewidth;\n				uniform vec2 resolution;\n\n				attribute vec3 instanceStart;\n				attribute vec3 instanceEnd;\n\n				#ifdef USE_COLOR\n					#ifdef USE_LINE_COLOR_ALPHA\n						varying vec4 vLineColor;\n						attribute vec4 instanceColorStart;\n						attribute vec4 instanceColorEnd;\n					#else\n						varying vec3 vLineColor;\n						attribute vec3 instanceColorStart;\n						attribute vec3 instanceColorEnd;\n					#endif\n				#endif\n\n				#ifdef WORLD_UNITS\n\n					varying vec4 worldPos;\n					varying vec3 worldStart;\n					varying vec3 worldEnd;\n\n					#ifdef USE_DASH\n\n						varying vec2 vUv;\n\n					#endif\n\n				#else\n\n					varying vec2 vUv;\n\n				#endif\n\n				#ifdef USE_DASH\n\n					uniform float dashScale;\n					attribute float instanceDistanceStart;\n					attribute float instanceDistanceEnd;\n					varying float vLineDistance;\n\n				#endif\n\n				void trimSegment( const in vec4 start, inout vec4 end ) {\n\n					// trim end segment so it terminates between the camera plane and the near plane\n\n					// conservative estimate of the near plane\n					float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n					float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n					float nearEstimate = - 0.5 * b / a;\n\n					float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n					end.xyz = mix( start.xyz, end.xyz, alpha );\n\n				}\n\n				void main() {\n\n					#ifdef USE_COLOR\n\n						vLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n					#endif\n\n					#ifdef USE_DASH\n\n						vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n						vUv = uv;\n\n					#endif\n\n					float aspect = resolution.x / resolution.y;\n\n					// camera space\n					vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n					vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n					#ifdef WORLD_UNITS\n\n						worldStart = start.xyz;\n						worldEnd = end.xyz;\n\n					#else\n\n						vUv = uv;\n\n					#endif\n\n					// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n					// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n					// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n					// perhaps there is a more elegant solution -- WestLangley\n\n					bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n					if ( perspective ) {\n\n						if ( start.z < 0.0 && end.z >= 0.0 ) {\n\n							trimSegment( start, end );\n\n						} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n							trimSegment( end, start );\n\n						}\n\n					}\n\n					// clip space\n					vec4 clipStart = projectionMatrix * start;\n					vec4 clipEnd = projectionMatrix * end;\n\n					// ndc space\n					vec3 ndcStart = clipStart.xyz / clipStart.w;\n					vec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n					// direction\n					vec2 dir = ndcEnd.xy - ndcStart.xy;\n\n					// account for clip-space aspect ratio\n					dir.x *= aspect;\n					dir = normalize( dir );\n\n					#ifdef WORLD_UNITS\n\n						// get the offset direction as perpendicular to the view vector\n						vec3 worldDir = normalize( end.xyz - start.xyz );\n						vec3 offset;\n						if ( position.y < 0.5 ) {\n\n							offset = normalize( cross( start.xyz, worldDir ) );\n\n						} else {\n\n							offset = normalize( cross( end.xyz, worldDir ) );\n\n						}\n\n						// sign flip\n						if ( position.x < 0.0 ) offset *= - 1.0;\n\n						float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n						// don't extend the line if we're rendering dashes because we\n						// won't be rendering the endcaps\n						#ifndef USE_DASH\n\n							// extend the line bounds to encompass  endcaps\n							start.xyz += - worldDir * linewidth * 0.5;\n							end.xyz += worldDir * linewidth * 0.5;\n\n							// shift the position of the quad so it hugs the forward edge of the line\n							offset.xy -= dir * forwardOffset;\n							offset.z += 0.5;\n\n						#endif\n\n						// endcaps\n						if ( position.y > 1.0 || position.y < 0.0 ) {\n\n							offset.xy += dir * 2.0 * forwardOffset;\n\n						}\n\n						// adjust for linewidth\n						offset *= linewidth * 0.5;\n\n						// set the world position\n						worldPos = ( position.y < 0.5 ) ? start : end;\n						worldPos.xyz += offset;\n\n						// project the worldpos\n						vec4 clip = projectionMatrix * worldPos;\n\n						// shift the depth of the projected points so the line\n						// segments overlap neatly\n						vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n						clip.z = clipPose.z * clip.w;\n\n					#else\n\n						vec2 offset = vec2( dir.y, - dir.x );\n						// undo aspect ratio adjustment\n						dir.x /= aspect;\n						offset.x /= aspect;\n\n						// sign flip\n						if ( position.x < 0.0 ) offset *= - 1.0;\n\n						// endcaps\n						if ( position.y < 0.0 ) {\n\n							offset += - dir;\n\n						} else if ( position.y > 1.0 ) {\n\n							offset += dir;\n\n						}\n\n						// adjust for linewidth\n						offset *= linewidth;\n\n						// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n						offset /= resolution.y;\n\n						// select end\n						vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n						// back to clip space\n						offset *= clip.w;\n\n						clip.xy += offset;\n\n					#endif\n\n					gl_Position = clip;\n\n					vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n					#include <logdepthbuf_vertex>\n					#include <clipping_planes_vertex>\n					#include <fog_vertex>\n\n				}\n			",fragmentShader:"\n				uniform vec3 diffuse;\n				uniform float opacity;\n				uniform float linewidth;\n\n				#ifdef USE_DASH\n\n					uniform float dashOffset;\n					uniform float dashSize;\n					uniform float gapSize;\n\n				#endif\n\n				varying float vLineDistance;\n\n				#ifdef WORLD_UNITS\n\n					varying vec4 worldPos;\n					varying vec3 worldStart;\n					varying vec3 worldEnd;\n\n					#ifdef USE_DASH\n\n						varying vec2 vUv;\n\n					#endif\n\n				#else\n\n					varying vec2 vUv;\n\n				#endif\n\n				#include <common>\n				#include <fog_pars_fragment>\n				#include <logdepthbuf_pars_fragment>\n				#include <clipping_planes_pars_fragment>\n\n				#ifdef USE_COLOR\n					#ifdef USE_LINE_COLOR_ALPHA\n						varying vec4 vLineColor;\n					#else\n						varying vec3 vLineColor;\n					#endif\n				#endif\n\n				vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n					float mua;\n					float mub;\n\n					vec3 p13 = p1 - p3;\n					vec3 p43 = p4 - p3;\n\n					vec3 p21 = p2 - p1;\n\n					float d1343 = dot( p13, p43 );\n					float d4321 = dot( p43, p21 );\n					float d1321 = dot( p13, p21 );\n					float d4343 = dot( p43, p43 );\n					float d2121 = dot( p21, p21 );\n\n					float denom = d2121 * d4343 - d4321 * d4321;\n\n					float numer = d1343 * d4321 - d1321 * d4343;\n\n					mua = numer / denom;\n					mua = clamp( mua, 0.0, 1.0 );\n					mub = ( d1343 + d4321 * ( mua ) ) / d4343;\n					mub = clamp( mub, 0.0, 1.0 );\n\n					return vec2( mua, mub );\n\n				}\n\n				void main() {\n\n					#include <clipping_planes_fragment>\n\n					#ifdef USE_DASH\n\n						if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n						if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n					#endif\n\n					float alpha = opacity;\n\n					#ifdef WORLD_UNITS\n\n						// Find the closest points on the view ray and the line segment\n						vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n						vec3 lineDir = worldEnd - worldStart;\n						vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n						vec3 p1 = worldStart + lineDir * params.x;\n						vec3 p2 = rayEnd * params.y;\n						vec3 delta = p1 - p2;\n						float len = length( delta );\n						float norm = len / linewidth;\n\n						#ifndef USE_DASH\n\n							#ifdef USE_ALPHA_TO_COVERAGE\n\n								float dnorm = fwidth( norm );\n								alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n							#else\n\n								if ( norm > 0.5 ) {\n\n									discard;\n\n								}\n\n							#endif\n\n						#endif\n\n					#else\n\n						#ifdef USE_ALPHA_TO_COVERAGE\n\n							// artifacts appear on some hardware if a derivative is taken within a conditional\n							float a = vUv.x;\n							float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n							float len2 = a * a + b * b;\n							float dlen = fwidth( len2 );\n\n							if ( abs( vUv.y ) > 1.0 ) {\n\n								alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n							}\n\n						#else\n\n							if ( abs( vUv.y ) > 1.0 ) {\n\n								float a = vUv.x;\n								float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n								float len2 = a * a + b * b;\n\n								if ( len2 > 1.0 ) discard;\n\n							}\n\n						#endif\n\n					#endif\n\n					vec4 diffuseColor = vec4( diffuse, alpha );\n					#ifdef USE_COLOR\n						#ifdef USE_LINE_COLOR_ALPHA\n							diffuseColor *= vLineColor;\n						#else\n							diffuseColor.rgb *= vLineColor;\n						#endif\n					#endif\n\n					#include <logdepthbuf_fragment>\n\n					gl_FragColor = diffuseColor;\n\n					#include <tonemapping_fragment>\n					#include <".concat(parseInt(i.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment",">\n					#include <fog_fragment>\n					#include <premultiplied_alpha_fragment>\n\n				}\n			"),clipping:!0}),this.isLineMaterial=!0,this.onBeforeCompile=function(){this.transparent?this.defines.USE_LINE_COLOR_ALPHA="1":delete this.defines.USE_LINE_COLOR_ALPHA},Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(e){this.uniforms.diffuse.value=e}},worldUnits:{enumerable:!0,get:function(){return"WORLD_UNITS"in this.defines},set:function(e){!0===e?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(e){this.uniforms.linewidth.value=e}},dashed:{enumerable:!0,get:function(){return"USE_DASH"in this.defines},set(e){!!e!="USE_DASH"in this.defines&&(this.needsUpdate=!0),!0===e?this.defines.USE_DASH="":delete this.defines.USE_DASH}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(e){this.uniforms.dashScale.value=e}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(e){this.uniforms.dashSize.value=e}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(e){this.uniforms.dashOffset.value=e}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(e){this.uniforms.gapSize.value=e}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(e){this.uniforms.opacity.value=e}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(e){this.uniforms.resolution.value.copy(e)}},alphaToCoverage:{enumerable:!0,get:function(){return"USE_ALPHA_TO_COVERAGE"in this.defines},set:function(e){!!e!="USE_ALPHA_TO_COVERAGE"in this.defines&&(this.needsUpdate=!0),!0===e?(this.defines.USE_ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.USE_ALPHA_TO_COVERAGE,this.extensions.derivatives=!1)}}}),this.setValues(e)}}},7934:function(e,n,t){"use strict";let i,r,o,a;t.d(n,{w:function(){return E}});var s=t(6376),l=t(1359),c=t(6934);let d=new s.Vector3,u=new s.Vector3,f=new s.Vector4,p=new s.Vector4,h=new s.Vector4,v=new s.Vector3,m=new s.Matrix4,y=new s.Line3,g=new s.Vector3,w=new s.Box3,S=new s.Sphere,b=new s.Vector4;function x(e,n,t){return b.set(0,0,-n,1).applyMatrix4(e.projectionMatrix),b.multiplyScalar(1/b.w),b.x=a/t.width,b.y=a/t.height,b.applyMatrix4(e.projectionMatrixInverse),b.multiplyScalar(1/b.w),Math.abs(Math.max(b.x,b.y))}class E extends s.Mesh{computeLineDistances(){let e=this.geometry,n=e.attributes.instanceStart,t=e.attributes.instanceEnd,i=new Float32Array(2*n.count);for(let e=0,r=0,o=n.count;e<o;e++,r+=2)d.fromBufferAttribute(n,e),u.fromBufferAttribute(t,e),i[r]=0===r?0:i[r-1],i[r+1]=i[r]+d.distanceTo(u);let r=new s.InstancedInterleavedBuffer(i,2,1);return e.setAttribute("instanceDistanceStart",new s.InterleavedBufferAttribute(r,1,0)),e.setAttribute("instanceDistanceEnd",new s.InterleavedBufferAttribute(r,1,1)),this}raycast(e,n){let t,l;let c=this.material.worldUnits,d=e.camera;null!==d||c||console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');let u=void 0!==e.params.Line2&&e.params.Line2.threshold||0;i=e.ray;let b=this.matrixWorld,E=this.geometry,_=this.material;if(a=_.linewidth+u,r=E.attributes.instanceStart,o=E.attributes.instanceEnd,null===E.boundingSphere&&E.computeBoundingSphere(),S.copy(E.boundingSphere).applyMatrix4(b),c)t=.5*a;else{let e=Math.max(d.near,S.distanceToPoint(i.origin));t=x(d,e,_.resolution)}if(S.radius+=t,!1!==i.intersectsSphere(S)){if(null===E.boundingBox&&E.computeBoundingBox(),w.copy(E.boundingBox).applyMatrix4(b),c)l=.5*a;else{let e=Math.max(d.near,w.distanceToPoint(i.origin));l=x(d,e,_.resolution)}w.expandByScalar(l),!1!==i.intersectsBox(w)&&(c?function(e,n){for(let t=0,l=r.count;t<l;t++){y.start.fromBufferAttribute(r,t),y.end.fromBufferAttribute(o,t);let l=new s.Vector3,c=new s.Vector3;i.distanceSqToSegment(y.start,y.end,c,l),c.distanceTo(l)<.5*a&&n.push({point:c,pointOnLine:l,distance:i.origin.distanceTo(c),object:e,face:null,faceIndex:t,uv:null,uv2:null})}}(this,n):function(e,n,t){let r=n.projectionMatrix,o=e.material.resolution,l=e.matrixWorld,c=e.geometry,d=c.attributes.instanceStart,u=c.attributes.instanceEnd,w=-n.near;i.at(1,h),h.w=1,h.applyMatrix4(n.matrixWorldInverse),h.applyMatrix4(r),h.multiplyScalar(1/h.w),h.x*=o.x/2,h.y*=o.y/2,h.z=0,v.copy(h),m.multiplyMatrices(n.matrixWorldInverse,l);for(let n=0,c=d.count;n<c;n++){if(f.fromBufferAttribute(d,n),p.fromBufferAttribute(u,n),f.w=1,p.w=1,f.applyMatrix4(m),p.applyMatrix4(m),f.z>w&&p.z>w)continue;if(f.z>w){let e=f.z-p.z,n=(f.z-w)/e;f.lerp(p,n)}else if(p.z>w){let e=p.z-f.z,n=(p.z-w)/e;p.lerp(f,n)}f.applyMatrix4(r),p.applyMatrix4(r),f.multiplyScalar(1/f.w),p.multiplyScalar(1/p.w),f.x*=o.x/2,f.y*=o.y/2,p.x*=o.x/2,p.y*=o.y/2,y.start.copy(f),y.start.z=0,y.end.copy(p),y.end.z=0;let c=y.closestPointToPointParameter(v,!0);y.at(c,g);let h=s.MathUtils.lerp(f.z,p.z,c),S=h>=-1&&h<=1,b=v.distanceTo(g)<.5*a;if(S&&b){y.start.fromBufferAttribute(d,n),y.end.fromBufferAttribute(u,n),y.start.applyMatrix4(l),y.end.applyMatrix4(l);let r=new s.Vector3,o=new s.Vector3;i.distanceSqToSegment(y.start,y.end,o,r),t.push({point:o,pointOnLine:r,distance:i.origin.distanceTo(o),object:e,face:null,faceIndex:n,uv:null,uv2:null})}}}(this,d,n))}}constructor(e=new l.z,n=new c.Y({color:16777215*Math.random()})){super(e,n),this.isLineSegments2=!0,this.type="LineSegments2"}}},1359:function(e,n,t){"use strict";t.d(n,{z:function(){return a}});var i=t(6376);let r=new i.Box3,o=new i.Vector3;class a extends i.InstancedBufferGeometry{applyMatrix4(e){let n=this.attributes.instanceStart,t=this.attributes.instanceEnd;return void 0!==n&&(n.applyMatrix4(e),t.applyMatrix4(e),n.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}setPositions(e){let n;e instanceof Float32Array?n=e:Array.isArray(e)&&(n=new Float32Array(e));let t=new i.InstancedInterleavedBuffer(n,6,1);return this.setAttribute("instanceStart",new i.InterleavedBufferAttribute(t,3,0)),this.setAttribute("instanceEnd",new i.InterleavedBufferAttribute(t,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(e){let n,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e instanceof Float32Array?n=e:Array.isArray(e)&&(n=new Float32Array(e));let r=new i.InstancedInterleavedBuffer(n,2*t,1);return this.setAttribute("instanceColorStart",new i.InterleavedBufferAttribute(r,t,0)),this.setAttribute("instanceColorEnd",new i.InterleavedBufferAttribute(r,t,t)),this}fromWireframeGeometry(e){return this.setPositions(e.attributes.position.array),this}fromEdgesGeometry(e){return this.setPositions(e.attributes.position.array),this}fromMesh(e){return this.fromWireframeGeometry(new i.WireframeGeometry(e.geometry)),this}fromLineSegments(e){let n=e.geometry;return this.setPositions(n.attributes.position.array),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new i.Box3);let e=this.attributes.instanceStart,n=this.attributes.instanceEnd;void 0!==e&&void 0!==n&&(this.boundingBox.setFromBufferAttribute(e),r.setFromBufferAttribute(n),this.boundingBox.union(r))}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new i.Sphere),null===this.boundingBox&&this.computeBoundingBox();let e=this.attributes.instanceStart,n=this.attributes.instanceEnd;if(void 0!==e&&void 0!==n){let t=this.boundingSphere.center;this.boundingBox.getCenter(t);let i=0;for(let r=0,a=e.count;r<a;r++)o.fromBufferAttribute(e,r),i=Math.max(i,t.distanceToSquared(o)),o.fromBufferAttribute(n,r),i=Math.max(i,t.distanceToSquared(o));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(e){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(e)}constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry",this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new i.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new i.Float32BufferAttribute([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}}}}]);